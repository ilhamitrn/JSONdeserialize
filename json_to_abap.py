import json
import re

class AbapStructureGenerator:
    def __init__(self):
        self.generated_types = {}
        self.global_mappings = [] 
        self.processed_structs = set()
        self.use_camel_to_snake = False 

    def generate_abap_types(self, json_input: str, root_name="ty_main_data", convert_names=False):
        try:
            # 1. Hazırlık
            data = json.loads(json_input)
            self.generated_types = {}
            self.global_mappings = []
            self.processed_structs = set()
            self.use_camel_to_snake = convert_names

            # 2. Analiz
            self._analyze_and_build(data, root_name)

            # 3. Rapor Kodunu Üret
            return self._build_full_report_code(root_name, json_input)

        except json.JSONDecodeError as e:
            return f"Hata: JSON formatı bozuk! -> {e}"

    def _analyze_and_build(self, data, struct_name):
        struct_name = self._sanitize_struct_name(struct_name)
        
        if struct_name in self.processed_structs:
            return
        self.processed_structs.add(struct_name)

        if not isinstance(data, dict):
            return

        field_lines = []
        local_field_names = set() 

        for key, value in data.items():
            abap_field = self._determine_abap_field_name(key, local_field_names)
            local_field_names.add(abap_field)

            # PARANOYAK MAPPING (Her şeyi haritala)
            self.global_mappings.append((abap_field, key))

            abap_type_def = ""
            
            if isinstance(value, list) and len(value) > 0:
                child_struct_name = f"ty_{abap_field.lower()}"
                table_type_name = f"tt_{abap_field.lower()}"

                if isinstance(value[0], dict):
                    unified_data = self._unify_list_items(value)
                    self._analyze_and_build(unified_data, child_struct_name)
                    abap_type_def = f"TYPE {table_type_name}"
                else:
                    abap_type_def = "TYPE string_table"

            elif isinstance(value, dict):
                child_struct_name = f"ty_{abap_field.lower()}"
                self._analyze_and_build(value, child_struct_name)
                abap_type_def = f"TYPE {child_struct_name}"

            else:
                abap_type_def = f"TYPE {self._infer_type(value)}"

            field_lines.append(f"    {abap_field:<31} {abap_type_def},")

        code = f"TYPES: BEGIN OF {struct_name},\n"
        code += "\n".join(field_lines)
        code += f"\n       END OF {struct_name}.\n"

        if "main" not in struct_name:
            tt_name = struct_name.replace('ty_', 'tt_')
            code += f"TYPES: {tt_name} TYPE STANDARD TABLE OF {struct_name} WITH EMPTY KEY.\n"

        self.generated_types[struct_name] = code

    def _build_full_report_code(self, root_name, original_json):
        """Doğrudan çalıştırılabilir Z Raporu üretir."""
        
        # --- DÜZELTME BURADA YAPILDI ---
        # 1. JSON içindeki yeni satırları (\n) sil. ABAP string literal'i alt satıra geçemez.
        # 2. ABAP için tek tırnakları escape et (' -> '')
        
        clean_json = original_json.replace('\n', '').replace('\r', '') # Satır sonlarını temizle
        escaped_json = clean_json.replace("'", "''")                   # Tırnakları düzelt
        
        # 200 karakterlik parçalara böl (Güvenli bölge)
        chunk_size = 200
        json_chunks = [escaped_json[i:i+chunk_size] for i in range(0, len(escaped_json), chunk_size)]
        
        final_code = "*&---------------------------------------------------------------------*\n"
        final_code += "*& Report Z_JSON_DESERIALIZE_TEST\n"
        final_code += "*& Generated by Python Tool - Syntax Fixed\n"
        final_code += "*&---------------------------------------------------------------------*\n"
        final_code += "REPORT z_json_deserialize_test.\n\n"
        
        final_code += "* --- 1. TYPE DEFINITIONS ---\n"
        for code_block in self.generated_types.values():
            final_code += code_block + "\n"

        sanitized_root = self._sanitize_struct_name(root_name)
        
        final_code += f"""
* --- 2. DATA DECLARATION ---
DATA: gs_data    TYPE {sanitized_root},
      lv_json    TYPE string,
      lt_mapping TYPE /ui2/cl_json=>name_mappings,
      ls_map     LIKE LINE OF lt_mapping.

START-OF-SELECTION.

* --- 3. BUILD JSON DATA ---
"""
        # Parçaları CONCATENATE ile birleştir
        for chunk in json_chunks:
            final_code += f"  CONCATENATE lv_json '{chunk}' INTO lv_json.\n"
            
        final_code += f"""
* --- 4. BUILD MAPPING TABLE ---
"""
        unique_mappings = sorted(list(set(self.global_mappings)), key=lambda x: x[0])
        
        for abap_f, json_k in unique_mappings:
            final_code += f"  ls_map-abap = '{abap_f}'. ls_map-json = '{json_k}'. INSERT ls_map INTO TABLE lt_mapping.\n"

        final_code += f"""
* --- 5. DESERIALIZE ---
  /ui2/cl_json=>deserialize(
    EXPORTING
      json          = lv_json
      pretty_name   = /ui2/cl_json=>pretty_mode-none 
      name_mappings = lt_mapping
    CHANGING
      data          = gs_data
  ).

* --- 6. DISPLAY RESULT ---
  IF gs_data IS INITIAL.
    WRITE: / 'HATA: Veri bos geldi!'.
  ELSE.
    cl_demo_output=>display( gs_data ).
  ENDIF.
"""
        return final_code

    def _sanitize_struct_name(self, name):
        clean = re.sub(r'[^a-zA-Z0-9]', '_', name)
        if self.use_camel_to_snake:
            s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', clean)
            clean = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
        clean = re.sub(r'_+', '_', clean).strip('_').lower()
        if not clean.startswith('ty_'):
            clean = f"ty_{clean}"
        return clean[:30]

    def _determine_abap_field_name(self, original_key, used_names):
        name_to_process = original_key
        if self.use_camel_to_snake:
            s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', original_key)
            name_to_process = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)

        clean = re.sub(r'[^a-zA-Z0-9]', '_', name_to_process).upper()
        clean = re.sub(r'_+', '_', clean).strip('_')
        
        if not clean: clean = "EMPTY_FIELD"
        if clean[0].isdigit(): clean = "F_" + clean

        candidate = clean[:30]
        counter = 2
        while candidate in used_names:
            suffix = f"_{counter}"
            trim_len = 30 - len(suffix)
            candidate = clean[:trim_len] + suffix
            counter += 1
        return candidate

    def _unify_list_items(self, list_data):
        unified = {}
        for item in list_data:
            if isinstance(item, dict):
                self._deep_merge(unified, item)
        return unified

    def _deep_merge(self, target, source):
        for k, v in source.items():
            if k in target and isinstance(target[k], dict) and isinstance(v, dict):
                self._deep_merge(target[k], v)
            elif k not in target:
                target[k] = v

    def _infer_type(self, value):
        if isinstance(value, bool): return "abap_bool"
        elif isinstance(value, int): return "int4"
        elif isinstance(value, float): return "p length 10 decimals 2"
        return "string"